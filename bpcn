bpcn() {
    # Default values
    local DEFAULT_MEMORY="16GB"
    local DEFAULT_CPUS=4
    local DEFAULT_TIME="8:00:00"
    local DEFAULT_PARTITION="cpu_medium"
    local SSH_HOST="${BPCN_SSH_HOST:-hpc}"
    local MEMORY=$DEFAULT_MEMORY
    local CPUS=$DEFAULT_CPUS
    local TIME=$DEFAULT_TIME
    local PARTITION=$DEFAULT_PARTITION
    local job_id=""

    # Cleanup function for interrupt handling
    cleanup() {
        if [[ -n "$job_id" ]]; then
            echo -e "\nInterrupted. Canceling job $job_id..." >&2
            cancel_job "$job_id"
        fi
    }

    # Function to print usage
    print_usage() {
        echo "Usage: bpcn [-m MEMORY] [-c CPUS] [-t TIME] [-p PARTITION] [-k] [-q] [-v]"
        echo "  -m MEMORY    Amount of memory per CPU to request (default: $DEFAULT_MEMORY)"
        echo "  -c CPUS      Number of CPUs to request (default: $DEFAULT_CPUS)"
        echo "  -t TIME      Time limit for the job (default: $DEFAULT_TIME)"
        echo "  -p PARTITION Partition to submit the job to (default: $DEFAULT_PARTITION)"
        echo "  -k           Kill/cancel the current compute node job"
        echo "  -q           Quiet mode (minimal output)"
        echo "  -v           Verbose mode (debug output)"
        echo "  -h           Display this help message"
        echo ""
        echo "Environment variables:"
        echo "  BPCN_SSH_HOST  SSH host alias (default: hpc)"
    }

    # Function to get the compute node
    get_compute_node() {
        ssh "$SSH_HOST" -- "squeue --me" 2>/dev/null | awk -v job_id="$1" '$1 == job_id {print $8}'
    }

    # Function to get the status of the job
    get_job_status() {
        ssh "$SSH_HOST" -- squeue --me 2>/dev/null | awk -v job_id="$1" '$1 == job_id {print $5}'
    }

    # Function to cancel the job
    cancel_job() {
        local jid="$1"
        ssh "$SSH_HOST" -- "scancel $jid" 2>/dev/null
    }

    # Function to kill current cn job
    kill_cn_job() {
        local cn_host
        cn_host=$(grep -A1 "^Host cn$" ~/.ssh/configx 2>/dev/null | grep HostName | awk '{print $2}')
        if [[ -z "$cn_host" ]]; then
            echo "Error: No compute node found in ~/.ssh/configx" >&2
            return 1
        fi
        local jid
        jid=$(ssh "$SSH_HOST" -- "squeue --me" 2>/dev/null | awk -v node="$cn_host" '$8 == node {print $1}')
        if [[ -z "$jid" ]]; then
            echo "Error: No running job found for compute node $cn_host" >&2
            return 1
        fi
        echo "Canceling job $jid on $cn_host..."
        cancel_job "$jid"
        echo "Job canceled."
    }

    # Function to get the estimated start time
    get_eta() {
        local jid="$1"
        local start_time=""
        local max_attempts=100
        local attempt=0
        
        # Get the estimated start time, retry if necessary
        while [[ -z "$start_time" ]] || [[ "$start_time" == "N/A" ]]; do
            if [[ $attempt -ge $max_attempts ]]; then
                echo "Error: Failed to get valid start time after $max_attempts attempts" >&2
                cancel_job "$jid"
                return 1
            fi
            
            start_time=$(ssh "$SSH_HOST" -- "squeue -j $jid --format=%S" 2>/dev/null | tail -n1)
            
            if [[ -z "$start_time" ]] || [[ "$start_time" == "N/A" ]]; then
                [[ "$VERBOSE" == "true" ]] && echo "Waiting for valid start time... ($((attempt + 1))/$max_attempts)" >&2
                sleep 6
                attempt=$((attempt + 1))
            fi
        done
        
        # Convert start time to seconds with OS detection
        local start_time_seconds
        local current_time
        current_time=$(date +%s)
        
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS (BSD date)
            start_time_seconds=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$start_time" +%s 2>/dev/null)
        else
            # Linux (GNU date)
            start_time_seconds=$(date -d "$start_time" +%s 2>/dev/null)
        fi
        
        # Check if conversion was successful
        if [[ -z "$start_time_seconds" ]]; then
            echo "Error: Could not parse start time" >&2
            return 1
        fi

        # If the start time is in the past, set it to the current time
        if [[ $start_time_seconds -lt $current_time ]]; then
            start_time_seconds=$current_time
        fi
        
        # Calculate and return wait time in seconds
        echo $((start_time_seconds - current_time))
    }

    # Parse options
    local QUIET="false"
    local VERBOSE="false"
    local KILL_MODE="false"
    OPTIND=1  # Reset for repeated calls
    while getopts "m:c:t:p:kqvh" opt; do
        case $opt in
            m) MEMORY="$OPTARG" ;;
            c) CPUS="$OPTARG" ;;
            t) TIME="$OPTARG" ;;
            p) PARTITION="$OPTARG" ;;
            k) KILL_MODE="true" ;;
            q) QUIET="true" ;;
            v) VERBOSE="true" ;;
            h) print_usage; return 0 ;;
            *) print_usage; return 1 ;;
        esac
    done

    # Handle kill mode
    if [[ "$KILL_MODE" == "true" ]]; then
        kill_cn_job
        return $?
    fi

    # Validate SSH connectivity first
    if ! ssh -q "$SSH_HOST" -- exit 2>/dev/null; then
        echo "Error: Cannot connect to $SSH_HOST. Check your SSH configuration." >&2
        return 1
    fi
    [[ "$VERBOSE" == "true" ]] && echo "SSH connection to $SSH_HOST verified."

    # Validate arguments
    if ! [[ $MEMORY =~ ^[0-9]+[MG]B$ ]]; then
        echo "Error: Invalid memory format. Example: 32GB or 420MB" >&2
        print_usage
        return 1
    fi

    if ! [[ $CPUS =~ ^[0-9]+$ ]]; then
        echo "Error: Invalid CPUs format. Must be an integer." >&2
        print_usage
        return 1
    fi

    if ! [[ $TIME =~ ^[0-9]+:[0-9]+:[0-9]+$ ]]; then
        echo "Error: Invalid time format. Must be in HH:MM:SS format." >&2
        print_usage
        return 1
    fi

    local valid_partitions="cpu_short|cpu_medium|cpu_long|cpu_dev|gpu4_dev|gpu4_short|gpu4_medium|gpu4_long|a100_dev|a100_short|a100_long"
    if ! [[ "$PARTITION" =~ ^($valid_partitions)$ ]]; then
        echo "Error: Invalid partition. Must be one of: ${valid_partitions//|/, }" >&2
        print_usage
        return 1
    fi

    # Set up interrupt handler
    trap cleanup INT TERM

    # Submit job to the BigPurple server
    local flags="--partition=$PARTITION --time=$TIME --mem-per-cpu=$MEMORY --cpus-per-task=$CPUS"
    local cmd="sbatch --parsable --job-name=vscode --nodes=1 $flags --output=logs/server-%j.out --wrap='sleep infinity'"
    
    # Calculate total memory for display
    local mem_value="${MEMORY%[MG]B}"
    local mem_unit="${MEMORY##*[0-9]}"
    local total_mem="$((mem_value * CPUS))${mem_unit}"

    if [[ "$QUIET" != "true" ]]; then
        echo "Requesting compute node with the following parameters:"
        echo "  Memory per CPU: $MEMORY"
        echo "  CPUs: $CPUS"
        echo "  Total Memory: $total_mem"
        echo "  Time: $TIME"
        echo "  Partition: $PARTITION"
    fi
    
    job_id=$(ssh "$SSH_HOST" -- "$cmd" 2>/dev/null)
    if [[ -z "$job_id" ]]; then
        echo "Error: Failed to submit job" >&2
        trap - INT TERM
        return 1
    fi
    [[ "$QUIET" != "true" ]] && echo "Job submitted with ID: $job_id"

    # Ensure the job partition configuration is correct
    local job_status
    job_status=$(get_job_status "$job_id")
    if [[ "$job_status" == "PartitionConfig" ]]; then
        echo "Error: Partition configuration is not valid. Please see http://bigpurple-ws.nyumc.org/wiki/index.php/Job-Scheduler" >&2
        cancel_job "$job_id"
        trap - INT TERM
        return 1
    fi
    
    # Get estimated wait time
    local eta
    if ! eta=$(get_eta "$job_id") || [[ -z "$eta" ]]; then
        echo "Error: Could not determine start time" >&2
        trap - INT TERM
        return 1
    fi
    [[ "$QUIET" != "true" ]] && echo "Estimated wait time: $eta seconds ($((eta / 60)) minutes)"

    # Wait for the job to start with periodic updates
    while [[ "$eta" -gt 0 ]]; do
        local wait_time=$((eta < 60 ? eta : 60))
        [[ "$QUIET" != "true" ]] && echo "Waiting for job to start... (ETA: $eta seconds / $((eta / 60)) minutes)"
        sleep "$wait_time"
        if ! eta=$(get_eta "$job_id") || [[ -z "$eta" ]]; then
            echo "Error: Could not determine updated start time or job was canceled" >&2
            cancel_job "$job_id"
            trap - INT TERM
            return 1
        fi
    done
    
    # Get the compute node and update SSH config
    local COMPUTE_NODE
    COMPUTE_NODE=$(get_compute_node "$job_id")
    if [[ -z "$COMPUTE_NODE" ]]; then
        echo "Error: No compute node allocated" >&2
        trap - INT TERM
        return 1
    fi
    [[ "$QUIET" != "true" ]] && echo "Compute node allocated: $COMPUTE_NODE"

    # Let's also get the remote user name
    local REMOTE_USER
    REMOTE_USER=$(ssh "$SSH_HOST" -- whoami 2>/dev/null)
    if [[ -z "$REMOTE_USER" ]]; then
        echo "Error: Could not determine remote user" >&2
        trap - INT TERM
        return 1
    fi

    # Update SSH config file
    cat > ~/.ssh/configx << EOF
Host cn
    HostName $COMPUTE_NODE
    User $REMOTE_USER
    ProxyJump $SSH_HOST
    LogLevel QUIET
    StrictHostKeyChecking accept-new
    ServerAliveInterval 60
    ServerAliveCountMax 5
EOF

    # Remove interrupt handler
    trap - INT TERM

    echo "SSH configuration updated. You can now connect using 'ssh cn'"
}